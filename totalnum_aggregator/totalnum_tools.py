import os

import pandas as pd
from ete3 import Tree


class Totalnum:
    def __init__(self):
        dfm_tot = []
        df = []
        dfp = []
        dfpm = []

    # Load a multisite totalnum report generated by totalnum_process. If minimal==False, also create a melted version and a percent version
    def init(self,pwd = "C:\\Users\\jgk12\\Google Drive\\SCILHS Phase II\\Committee, Cores, Panels\\Informatics & Technology Core\\totalnums",fname='joined.csv',minimal=False):
        #print(sys.argv)
        cwd = os.getcwd()
        os.chdir(pwd)
        print("Loading totalnums...")
        self.df  = self.totalnum_load(fname)
        if not minimal:
            print("Post-processing...")
            self.dfp = self.convert_to_pct(self.df)
            self.dfm = self.totalnum_melt(self.df)
            self.dfpm = self.totalnum_melt(self.dfp)
        print("Ready!")
        os.chdir(cwd)

    def convert_to_pct(self,df):
        global dfm_tot

        # Compute the sum of patients with a sex value and make a data frame of percentages dfp
        dfm_temp = pd.melt(df.loc[[v for v in df.index.get_values() if v.startswith("\\PCORI\\DEMOGRAPHIC\\SEX\\")]],
                           id_vars=['c_name', 'domain', 'c_hlevel'], var_name='site', value_name='c')
        dfm_temp = dfm_temp.where(dfm_temp.c_hlevel > 4)[['site', 'c']].groupby('site').sum().T
        self.dfm_tot = dfm_temp
        dfp = pd.concat([df.ix[:, 0:3], df.ix[:, 3:].divide(dfm_temp.loc[dfm_temp.index[0]], axis='columns') * 100],
                        axis='columns')

        return dfp

    def totalnum_melt(self,df):
        # Melt all of report2 dfm and dfpm
        #dfm = pd.melt(df, id_vars=['c_name', 'domain', 'c_hlevel'], var_name='site', value_name='c')
        # Update 09-12-18: now include the fullname as index in the melt
        # WARNING: Doesn't work with my recent export, which doesn't name the index! :(
        dfm=pd.melt(df.reset_index(), id_vars=['c_fullname','c_name', 'domain', 'c_hlevel'], var_name='site', value_name='c').set_index('c_fullname')
        
        return dfm

    # Pass either a filename or dataframe of totalnums
    def totalnum_load(self,fname="",df=None):
        if not df:
            df = pd.read_csv(fname,index_col=0)
        # Remove all-null rows
        df = df.loc[(df.ix[:,3:]!=0).any(axis=1)]
        # Add c_hlevel and domain columns
        df.insert(1,"c_hlevel",[x.count("\\") for x in df.index])
        df.insert(1,"domain",[x.split('\\')[2] if "PCORI_MOD" not in x else "MODIFIER" for x in df.index])
        # Convert totalnums to floats
        df = pd.concat([df.ix[:,0:3],(df.ix[:,3:].apply(pd.to_numeric,errors="coerce"))],axis=1)
        # Remove RAW values
        df = df[~df.c_name.str.contains("RAW_", na=False)]
        # Truncate c_name at 200 characters
        df.c_name = df.c_name.str[:200]
        # Wrap words at 50 chars, only up to hlevel 7 (takes too long otherwise)
        df.loc[df.c_hlevel<7,'c_name']=self.wordwrap_dfcol(df[df.c_hlevel<7],'c_name',40)
        # Rename totalnum columns - remove totalnum_ or totalnum_c1 and uppercase
        df = df.rename(columns=lambda x: '#'+x[x.find('_') + 1:].upper()[2 if 'c1' in x else 0:] if 'totalnum' in x else x)
        # Add sum column
        sum = df[df.columns[df.columns.str.contains("#")]].sum(axis=1)
        sum.name = 'sum'
        df=pd.concat([df, sum], axis=1)

        return df

    def get_tree_child_by_name(self, n: object, t: object)  -> object:
        c = n.get_children()
        for k in c:
            if k.name==t: return k
        return None

    def build_tree(self, dft) -> object:
        tr = Tree()
        for index, row in dft[dft.index.str.startswith("\\PCORI\\")][dft.c_hlevel==3].iterrows():
            tn = tr.add_child(name=row['c_name'])
        for i in sorted(dft.c_hlevel.unique())[1:]:
            for index, row in dft[dft.index.str.startswith("\\PCORI\\")][dft.c_hlevel==i].iterrows():
                #print(index)
                t = index[:index[:-1].rfind("\\")+1]
                if t in dft.index.values:
                    l = tr.search_nodes(name=dft.loc[t]["c_name"])
                    #print (dft.loc[t]["c_name"])
                    if l is not None and len(l)>0:
                        tn = l[0].add_child(name=row['c_name'])
                        #print(":"+row['c_name'])
        return tr

    def prep_plot(self,df,hlevel=0,domain=None,pct=True) -> object:
        dfo = df
        if (hlevel>0): dfo = dfo[dfo.c_hlevel == hlevel]
        if (domain): dfo = dfo[dfo.domain == domain]
        else: dfo=dfo[dfo.domain != "MODIFIER"]
        if (pct): dfo = dfo[dfo<100]

        dfo = dfo.reset_index().set_index('c_name').drop(['index', 'domain', 'c_hlevel'], axis=1)
        dfo = dfo.fillna(value=dfo.max().max()*-0.1)
        return dfo

    # Wrap string v at first space after l characters, Inserts a <br>, not \n
    def wordwrap(self,v,l):
        out =[]
        vss = v.split(" ")
        i=0
        for vs in vss:
            i+=len(vs)
            if(i>=l):
                i=0
                out.append(vs+"<br>")
            else:
                out.append(vs+" ")
        outret=''.join(out)
        if outret[-1]==' ': return outret[:-1]
        else: return outret

    # Apply this to a dataframe
    # Not in placee ....
    # Run this like: tot.df.loc[tot.df.c_hlevel<7,'c_name']=wordwrap_dfcol(tot.df[tot.df.c_hlevel<7],'c_name',40)
    def wordwrap_dfcol(self,df,colname,l):
        return df.apply(lambda row: self.wordwrap(row[colname],l),axis=1)#wordwrap(row[colname],l)), axis=1)